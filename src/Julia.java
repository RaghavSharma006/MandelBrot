import javax.swing.*;
import javax.swing.event.MouseInputListener;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class Julia extends JPanel implements MouseInputListener {

    // Screen dimensions taken from system display
    final static int SCREEN_HEIGHT;
    final static int SCREEN_WIDTH;

    // Iteration limit for Julia set calculations
    final static int MAX_ITERATIONS = 1000;

    // Julia set constants (fixed complex number c = c_a + c_b*i)
    final double c_a;
    final double c_b;

    // Zoom factor (how much we zoom in/out per double click)
    final double ZOOM_FACTOR = 0.8;

    // Current rectangle boundaries in complex plane
    double xMin = -2.5;
    double xMax = 2.5;
    double yMin = -2.5;
    double yMax = 2.5;

    // The image buffer where we render pixels
    BufferedImage img;

    // Static initializer: detect screen resolution
    static {
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        SCREEN_WIDTH = screen.width;
        SCREEN_HEIGHT = screen.height;
    }

    // Constructor when Julia set is generated by clicking Mandelbrot
    Julia(double mouseX, double mouseY, int a) {
        // Convert mouse coordinates into complex plane
        c_a = xMin + (mouseX / (double) SCREEN_WIDTH) * (xMax - xMin);
        c_b = yMin + (mouseY / (double) SCREEN_HEIGHT) * (yMax - yMin);

        generate();

        addMouseListener(this);
        addMouseMotionListener(this);
    }

    // Constructor when Julia set is directly given a complex constant
    Julia(double real, double imaginary) {
        c_a = real;
        c_b = imaginary;
        generate();
    }

    // Generate Julia set image
    void generate() {
        img = new BufferedImage(SCREEN_WIDTH, SCREEN_HEIGHT, BufferedImage.TYPE_INT_RGB);

        for (int i = 0; i < SCREEN_WIDTH; i++) {
            for (int j = 0; j < SCREEN_HEIGHT; j++) {

                // Convert pixel to complex plane coordinate (z)
                double z_a = xMin + (i / (double) SCREEN_WIDTH) * (xMax - xMin);
                double z_b = yMin + (j / (double) SCREEN_HEIGHT) * (yMax - yMin);

                int numberOfIterations = 0;

                // Iterate z -> zÂ² + c until it diverges or reaches max iterations
                while ((z_a * z_a) + (z_b * z_b) <= 4 && numberOfIterations < MAX_ITERATIONS) {
                    double zn_a = (z_a * z_a) - (z_b * z_b) + (c_a);  // Real part
                    double zn_b = 2 * (z_a * z_b) + (c_b);            // Imaginary part

                    z_a = zn_a;
                    z_b = zn_b;
                    numberOfIterations++;
                }

                // Coloring: black if inside, else color based on iteration count
                int color = numberOfIterations == MAX_ITERATIONS
                        ? 0
                        : Color.HSBtoRGB(
                        numberOfIterations / 256f,
                        1,
                        numberOfIterations / (numberOfIterations + 8f)
                );

                // Flip vertically (because screen y-axis is inverted compared to complex plane)
                img.setRGB(i, SCREEN_HEIGHT - 1 - j, color);
            }
        }
    }

    // Draw Julia set image
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.drawImage(img, 0, 0, null);
    }

    boolean isGenerating = false;

    // Zoom on double click
    @Override
    public void mouseClicked(MouseEvent e) {
        if (e.getClickCount() == 2) {
            if (isGenerating || isDragging) return;
            else isGenerating = true;

            // Zoom in if left click, zoom out if right click
            double scale;
            if (e.getButton() == MouseEvent.BUTTON1) scale = ZOOM_FACTOR;
            else scale = 1.0 / ZOOM_FACTOR;

            // Mouse position in complex plane
            double xCenter = xMin + (e.getX() / (double) SCREEN_WIDTH) * (xMax - xMin);
            double yCenter = yMin + (e.getY() / (double) SCREEN_HEIGHT) * (yMax - yMin);

            // Relative fractions (important for scaling)
            double fx = e.getX() / (double) SCREEN_WIDTH;
            double fy = e.getY() / (double) SCREEN_HEIGHT;

            // New zoomed rectangle size
            double newWidth = (xMax - xMin) * scale;
            double newHeight = (yMax - yMin) * scale;

            // Reposition rectangle around mouse click
            xMin = xCenter - (fx * newWidth);
            xMax = xMin + newWidth;

            yMin = yCenter - (fy * newHeight);
            yMax = yMin + newHeight;

            generate();
            repaint();
            isGenerating = false;
        }
    }

    double dragStartX, dragStartY;
    boolean isDragging = false;

    // Start dragging
    @Override
    public void mousePressed(MouseEvent e) {
        dragStartX = e.getX();
        dragStartY = e.getY();
        isDragging = true;
    }

    // Handle dragging (panning)
    @Override
    public void mouseDragged(MouseEvent e) {
        if (!isDragging || isGenerating) return;

        // Pixel movement
        double dx = dragStartX - e.getX();
        double dy = dragStartY - e.getY();

        // Convert to complex plane shift
        double xCenter = (dx / SCREEN_WIDTH) * (xMax - xMin);
        double yCenter = (dy / SCREEN_HEIGHT) * (yMax - yMin);

        // Shift view window
        xMin += xCenter;
        xMax += xCenter;
        yMin -= yCenter;   // Notice minus because screen y is inverted
        yMax -= yCenter;

        dragStartX = e.getX();
        dragStartY = e.getY();

        generate();
        repaint();
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        isDragging = false;
    }

    @Override
    public void mouseEntered(MouseEvent e) {}
    @Override
    public void mouseExited(MouseEvent e) {}
    @Override
    public void mouseMoved(MouseEvent e) {}
}
